<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Generates fractal-like patterns based on an initial seed</title>
		<style>
			body {
				background-color: black;
				color: white;
			}
			.settingsBox {
				border-style: solid;
				border-color: white;
				border-width: 2px;
			}
		</style>
	</head>
	<body>
		<ul>
			<li>Generates a small N x N grid of numbers from 0 to 1</li>
			<li>Uses this to generate a larger grid of numbers (by default a N<sup>2</sup> x N<sup>2</sup> grid)</li>
			<li>Uses this new grid to draw pixels on the canvas, with the largest number corresponding to a white pixel and the lowest number corresponding to 0</li>
		</ul>
		<br>
		<div class = "settingsBox">
			<ul>
				<li><label for='gridWidth'>Grid Width:</label><input type="number" value = 8 id='gridWidth'></li>
				<li><label for='gridHeight'>Grid Height:</label><input type="number" value = 8 id='gridHeight'></li>
				<li><label for='gridWidthScale'>Grid Width multiplier:</label><input type="number" value = 8 id='gridWidthScale'></li>
				<li><label for='gridHeightScale'>Grid Height multiplier:</label><input type="number" value = 8 id='gridHeightScale'></li>
				<li><label for='blackWhite'>Monochrome:</label><input type="checkbox" id='blackWhite'></li>
				<li><label for='stretchTile'>Tiled (leave off for Stretched):</label><input type="checkbox" id='stretchTile'></li>
			</ul>
		</div>
		<br>
			<div class = "settingsBox colorsBox">
			<p>Change which colors are used to generate the patterns</p>
			<em>START COLOR</em><br> 
				<label for='start_r'>R</label><input type="number" value = 0 id='start_r'>
				<label for='start_g'>G</label><input type="number" value = 0 id='start_g'>
				<label for='start_b'>B</label><input type="number" value = 0 id='start_b'>
			<br>
			<em>END COLOR</em><br>
				<label for='end_r'>R</label><input type="number" value = 255 id='end_r'>
				<label for='end_g'>G</label><input type="number" value = 255 id='end_g'>
				<label for='end_b'>B</label><input type="number" value = 255 id='end_b'>
			
		</div>
		<br>
		<div class = "settingsBox">
				<p>Pressing "Update" randomizes the grid and applies new width/height/multiplier values.</p>
				<p>"Redraw" lets you switch from Stretched to Tiled mode (and change colors).</p>
				<input type="button" value="UPDATE" onclick="Update()"></input>
				<input type="button" value="REDRAW" onclick="Redraw()"></input>
		</div>
		<br>
		<canvas id='c' width = 800 height = 800></canvas>
		
		<script>
		
			
		
			const canvas = document.querySelector('#c');
			
			const ctx = canvas.getContext('2d');
			
			const RandomNumbersArray = (w = 2, h = 2) => Array(h).fill(0).map( r => Array(w).fill(0).map( c => Math.random() ) );
			
			const RandomNumbersArrayBias = (w = 2, h = 2, b = 0.5) => Array(h).fill(0).map( r => Array(w).fill(0).map( c => Math.random() > b ? 1 : 0 ) );
			
			const clamp = (value, min, max) => (value < min) ? min : (value > max) ? max : value;
			
			class rgbColor {
				constructor(r, g, b) {
					this.r = Math.floor(clamp(r, 0, 255));
					this.g = Math.floor(clamp(g, 0, 255));
					this.b = Math.floor(clamp(b, 0, 255));
				}
				color() {
					return `rgb(${this.r},${this.g},${this.b})`;
				}
			}		
			
			// generate a color that's "between" two colors
			const colorBetween = (value, start_color, end_color) => {
				if (value >= 1) {return end_color;}
				else if (value <= 0) {return start_color;}
				
				let r = lerp(value, start_color.r, end_color.r);
				let g = lerp(value, start_color.g, end_color.g);
				let b = lerp(value, start_color.b, end_color.b);
				
				return new rgbColor(r, g, b);
			};
			
			const idiv = (a, b) => Math.floor(a / b);
			
			const ArrayEnlarge = (arr, w_factor, h_factor) => {
				let h = arr.length;
				let w = arr[0].length;
				let new_h = h * h_factor;
				let new_w = w * w_factor;
				
				return Array(new_h).fill(0).map(
					(_, r) => Array(new_w).fill(0).map(
						(_, c) => arr[r % h][c % w] * arr[ idiv(r, h) % h][ idiv(c, w) % w ]
					)
				);
			};
			
			const ArraySquare = (arr) => ArrayEnlarge(arr, arr[0].length, arr.length);
			
			const findGridMinMax = (arr) => { 
				let min = 1;
				let max = 0;
				
				arr.map(
					(_, r) => arr[r].map( 
						(_, c) => {
							max = (arr[r][c] > max) ? arr[r][c] : max;
							min = (arr[r][c] < min) ? arr[r][c] : min;
							
						}
					)
				);
				let range = max - min;
				
				return {Min: min, Max: max, Range: range};
			};
			
			const lerp = (t, v0, v1) => (v1 * clamp(t, 0, 1) ) + (v0 * (1 - clamp(t, 0, 1) ));
			
			const mapRange = (value, min1, max1, min2, max2) => lerp( (value - min1) / (max1 - min1) , min2, max2);

			//Parameters			
			let arr = RandomNumbersArray();
			let arr_width = 8;
			let arr_height = 8;
			let arr_wscale = 8;
			let arr_hscale = 8;
			let BW = false;
			let Tiled = false;
			
			let start_color = new rgbColor(0, 0, 0);
			let end_color = new rgbColor(255, 255, 255);
			
			const makeColorArray = (arr) => {
				let w = arr[0].length;
				let h = arr.length;
				let x = findGridMinMax(arr);
				let max = x.Max;
				let min = x.Min;
				let range = x.Range;
			
			
				return Array(h).fill(0).map( (_,r) => Array(w).fill(0).map(
					(_, c) => 
						colorBetween( (arr[r][c] - min) / range, start_color, end_color)
						//mapRange(arr[r][c], min, max, 0, 255)		
					) 
				);
			}
			
			let color_arr = makeColorArray(arr);

			const drawGridStretched = (arr) => {
				ctx.fillStyle = 'black';
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				
				let _w = clamp(idiv(canvas.width, arr[0].length), 1, canvas.width);
				let _h = clamp(idiv(canvas.height, arr.length), 1, canvas.height);
			
				arr.map( (_, r) => arr[r].map( (_,c) =>
					{
						ctx.fillStyle = arr[r][c].color() //`rgb(${arr[r][c]}, ${arr[r][c]}, ${arr[r][c]})`;
						ctx.fillRect(c*_w, r*_h, _w, _h);
					}
				));
			};
			
			const drawGridTiled = (arr) => {
				ctx.fillStyle = 'black';
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				let h = arr.length;
				let w = arr[0].length;
				
				Array(canvas.height).fill(0).map( (_, r) => Array(canvas.width).fill(0).map( 
					(_, c) => {
						ctx.fillStyle = arr[r % h][c % w].color();
						ctx.fillRect(r, c, 1, 1);
					}
				));
			
			}	
			
			const getBooleanValueOfInput = (inputID, defaultValue = false) => {
				return document.getElementById(inputID).checked;
			};
			
			const getNumericalValueOfInput = (inputID, defaultValue = 0) => { 
				let getNum = parseInt( document.getElementById(inputID).value );
				return isNaN(getNum) ? defaultValue : getNum;				
			};
			
			const getColorsFromFields = () => {
				let r1 = getNumericalValueOfInput('start_r', 0);
				let g1 = getNumericalValueOfInput('start_g', 0);
				let b1 = getNumericalValueOfInput('start_b', 0);
				
				let r2 = getNumericalValueOfInput('end_r', 0);
				let g2 = getNumericalValueOfInput('end_g', 0);
				let b2 = getNumericalValueOfInput('end_b', 0);
				
				start_color = new rgbColor(r1, g1, b1);
				end_color = new rgbColor(r2, g2, b2);
			};
			
			const draw = (newArray = true) => {
			
				if (newArray) {
					arr = (BW) ? RandomNumbersArrayBias(arr_width,arr_height) : RandomNumbersArray(arr_width,arr_height);
					arr =  ArrayEnlarge( arr , arr_wscale, arr_hscale);
				}
				
				color_arr = makeColorArray(arr);
				
				if (!Tiled) { drawGridStretched(color_arr); } else { drawGridTiled(color_arr); }
			};
			
			const Redraw = () => {
				Tiled = getBooleanValueOfInput('stretchTile', false);
				getColorsFromFields();
				draw(false);
			};
			
			const Update = () => {
				arr_width = getNumericalValueOfInput('gridWidth', 8);
				arr_height= getNumericalValueOfInput('gridHeight', 8);
				arr_wscale = getNumericalValueOfInput('gridWidthScale', 2);
				arr_hscale= getNumericalValueOfInput('gridHeightScale', 2);
				BW = getBooleanValueOfInput('blackWhite', false);
				
				getColorsFromFields();
				
				
				Tiled = getBooleanValueOfInput('stretchTile', false);
				draw(true);
			};
			
			Update();
		</script>
	</body>
</html>
